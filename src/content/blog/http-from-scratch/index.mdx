---
title: "HTTP from Scratch"
description: "Learn how to build a web server from the ground up, using C++."
tags: ["http", "c++", "networking", "programming"]
pubDate: "Aug 14 2025"
---

# Learn the HTTP Protocol in C++
**A Comprehensive Course Building HTTP Servers from Scratch**

> This is a hands‑on, incremental course. Each chapter now ends with a short set of "Reader Tasks" (mini‑exercises) to solidify the concepts before moving on. All code blocks have been cleaned up to be self‑contained (or clearly marked as partial) and should compile when copied into a minimal project unless explicitly labeled as a focused excerpt.

This extensive course takes you on a journey from basic file operations to building a production-ready HTTP server in C++, following the proven Boot.dev methodology adapted for C++ development. You'll understand **every layer** of the network stack, implement the HTTP/1.1 protocol from scratch, and gain deep insights into how web servers actually work.[1][2][3]
## Course Overview
This course teaches you to build HTTP functionality using **only standard C++ libraries** and system calls. By the end, you'll have implemented a complete HTTP/1.1 server capable of handling real-world requests, serving files, and processing binary data.[3][4][5][6][7]

### Prerequisites
- **Basic C++ knowledge**: Classes, pointers, memory management
- **Compilation experience**: Using g++/clang++ and basic Makefiles
- **Command line comfort**: Running programs and basic shell commands
- **Network curiosity**: Desire to understand how the internet works

### What You'll Build
- A **complete HTTP/1.1 server** from TCP primitives[8][3]
- **Thread-safe communication channels** using modern C++[9][10]
- **Robust HTTP parser** with comprehensive error handling[11][12]
- **Production-ready project structure** with CMake and testing[13][14]
***

## Chapter 1: HTTP Streams - Foundation of Data Processing
### The TheStartup™ Challenge
Welcome to **TheStartup™**! You've been hired to build a revolutionary HTTP server from scratch. But before tackling the full protocol, you need to master the fundamentals: efficient data streaming and processing.[15][16]

### 1.1 Introduction: Why Start with Files?
Network connections and files are both **streams of bytes**. By mastering file I/O patterns, you'll understand the core concepts needed for network programming. This abstraction allows us to build reusable code that works with both files and sockets.[4][5][17][18]

### 1.2 Reading Files in 8-Byte Chunks
Let's start with the foundation - reading data efficiently in small chunks while maintaining performance.[19][15]  
Reading in fixed-size chunks lets you reason about buffering & streaming just like sockets. We'll intentionally use a tiny `CHUNK_SIZE` (8) so boundary behavior becomes obvious during experimentation.

Before you read the code, try to predict:
1. How many iterations will it take to read the provided example file?  
2. What happens if the file length is exactly divisible by 8?  
3. Where does the final partial chunk get handled?  
4. How would you adapt this for stdin (no file length known up front)?
5. What if the file is huge (multi‑GB) — does memory usage grow?

```cpp
// file_read_chunks.cpp
// Demonstrates fixed-size buffered file reading.  
// Lesser-known header note: <vector> gives us a contiguous dynamic buffer we can reuse each iteration.
// Try experimenting with CHUNK_SIZE values (8, 256, 4096) and watch performance & boundary effects.

#include <iostream>
#include <fstream>
#include <vector>
#include <string>

int main() {
    constexpr std::size_t CHUNK_SIZE = 8; // Deliberately tiny for pedagogy
    std::ifstream file("messages.txt", std::ios::binary);
    if (!file) {
        std::cerr << "Error opening file\n";
        return 1;
    }

    std::vector<char> buffer(CHUNK_SIZE);

    while (file.read(buffer.data(), CHUNK_SIZE)) {
        std::cout.write(buffer.data(), file.gcount());
    }

    // Process trailing partial block (if any)
    if (file.gcount() > 0) {
        std::cout.write(buffer.data(), file.gcount());
    }
}
```

Create your `messages.txt` file:
``` txt
Do you have what it takes to be an engineer at TheStartup™?
Are you willing to work 80 hours a week in hopes that your 0.001% equity is worth something?
Can you say "synergy" and "democratize" with a straight face?
Are you prepared to eat top ramen at your desk 3 meals a day?
end
```

### 1.3 Line-by-Line Processing with State Machines
Real applications need to process data **line-by-line** while reading in fixed chunks. This requires maintaining state between read operations:[12][20]

Before you read the code, think about:
1. Which variable preserves unfinished line fragments across chunk boundaries?  
2. What edge case occurs when two newlines appear back‑to‑back?  
3. How would you detect extremely long lines (potential DOS)?  
4. Could you avoid `std::stringstream` here? What trade‑offs?  
5. How would Windows CRLF input (`\r\n`) change logic?

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>

int main() {
    const size_t CHUNK_SIZE = 8;
    std::ifstream file("messages.txt", std::ios::binary);
    if (!file.is_open()) {
        std::cerr << "Error opening file" << std::endl;
        return 1;
    }
    
    std::vector<char> buffer(CHUNK_SIZE);
    std::string currentLine;  // State maintained between reads
    
    while (file.read(buffer.data(), CHUNK_SIZE)) {
        std::streamsize bytesRead = file.gcount();
        std::string chunk(buffer.data(), bytesRead);
        
        // Split chunk on newlines
        std::stringstream ss(chunk);
        std::string segment;
        std::vector<std::string> parts;
        
        while (std::getline(ss, segment)) {
            parts.push_back(segment);
        }
        
        // Process complete lines
        for (size_t i = 0; i < parts.size(); ++i) {
            if (i == 0) {
                // First part continues previous line
                currentLine += parts[i];
                if (parts.size() > 1) {
                    // There was a newline, so line is complete
                    std::cout << "Complete line: " << currentLine << std::endl;
                    currentLine.clear();
                }
            } else if (i == parts.size() - 1) {
                // Last part might be incomplete
                currentLine = parts[i];
            } else {
                // Middle parts are complete lines
                std::cout << "Complete line: " << parts[i] << std::endl;
            }
        }
    }
    
    // Handle final partial line
    if (!currentLine.empty()) {
        std::cout << "Final line: " << currentLine << std::endl;
    }
    
    file.close();
    return 0;
}
```

**Key Concepts:**
- **Fixed chunk size**: Consistent 8-byte reads for controlled boundaries[19]
- **State machine**: `currentLine` accumulates across chunk boundaries[12][20]
- **Edge cases**: Handles lines split exactly at buffer edge[21]
- **Memory safety**: `std::vector<char>` avoids raw new/delete[19]
- **I/O pattern**: Same pattern applies to sockets (just replace `file.read` with `recv`).

**Reader Tasks (after 1.3)**
1. Change `CHUNK_SIZE` to 5 and observe how often a line is split.  
2. Count the number of system calls by wrapping `file.read` with a counter.  
3. Add logic to number each completed line.  
4. Extend the program to emit JSON lines: `{ "line_no": N, "text": "..." }`.  
5. (Stretch) Replace `std::ifstream` with `stdin` reading (`std::cin.read`) and pipe data in.

### 1.4 Thread-Safe Channels for Communication
Building on our line processing foundation, let's create **Go-style channels** for thread-safe communication:[23][24][25]

Before you read the code, ask yourself:
1. What happens if `receive()` is called after `close()` with an empty queue?  
2. Could a lost wakeup occur here? Why/why not?  
3. Where might spurious wakeups matter?  
4. Is `send` blocking or non‑blocking? What would need to change for backpressure?  
5. How could you add cancellation?

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

template<typename T>
class Channel {
private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;
    bool closed_ = false;

public:
    void send(const T& item) {
        std::lock_guard lock(mutex_);
        if (!closed_) {
            queue_.push(item);
            condition_.notify_one();
        }
    }
    
    bool receive(T& item) {
        std::unique_lock lock(mutex_);
        while (queue_.empty() && !closed_) {
            condition_.wait(lock);
        }
        
        if (!queue_.empty()) {
            item = queue_.front();
            queue_.pop();
            return true;
        }
        
        return false; // Channel closed and empty
    }
    
    void close() {
        std::lock_guard lock(mutex_);
        closed_ = true;
        condition_.notify_all();
    }
};

Channel<std::string> readLines(std::istream& input) {
    Channel<std::string> channel;
    
    std::thread readerThread([&channel, &input]() {
        const size_t CHUNK_SIZE = 8;
        std::vector<char> buffer(CHUNK_SIZE);
        std::string currentLine;
        
        while (input.read(buffer.data(), CHUNK_SIZE)) {
            std::streamsize bytesRead = input.gcount();
            std::string chunk(buffer.data(), bytesRead);
            
            std::stringstream ss(chunk);
            std::string segment;
            std::vector<std::string> parts;
            
            while (std::getline(ss, segment)) {
                parts.push_back(segment);
            }
            
            for (size_t i = 0; i < parts.size(); ++i) {
                if (i == 0) {
                    currentLine += parts[i];
                    if (parts.size() > 1) {
                        channel.send(currentLine);
                        currentLine.clear();
                    }
                } else if (i == parts.size() - 1) {
                    currentLine = parts[i];
                } else {
                    channel.send(parts[i]);
                }
            }
        }
        
        if (!currentLine.empty()) {
            channel.send(currentLine);
        }
        
        channel.close();
    });
    
    readerThread.detach();
    return channel;
}
```

**Reader Tasks (after 1.4)**
1. Add a `try_send` method that returns `false` if the channel is closed instead of silently ignoring.  
2. Add a `size()` accessor guarded by a mutex for debugging.  
3. Introduce a bounded channel (max N items) – the sender should wait if the queue is full.  
4. Benchmark: measure throughput difference between CHUNK_SIZE = 8 vs 1024.  
5. Replace the detached thread with `std::jthread` (C++20) and a stop token (if available in your environment).

``` cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <sstream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

// [Include Channel class from previous section]

Channel<std::string> getLinesChannel(int socket_fd) {
    Channel<std::string> channel;
    
    std::thread readerThread([channel = std::move(channel), socket_fd]() mutable {
        const size_t CHUNK_SIZE = 8;
        std::vector<char> buffer(CHUNK_SIZE);
        std::string currentLine;
        
        ssize_t bytesRead;
        while ((bytesRead = recv(socket_fd, buffer.data(), CHUNK_SIZE, 0)) > 0) {
            std::string chunk(buffer.data(), bytesRead);
            
            std::stringstream ss(chunk);
            std::string segment;
            std::vector<std::string> parts;
            
            while (std::getline(ss, segment)) {
                parts.push_back(segment);
            }
            
            for (size_t i = 0; i < parts.size(); ++i) {
                if (i == 0) {
                    currentLine += parts[i];
                    if (parts.size() > 1) {
                        channel.send(currentLine);
                        currentLine.clear();
                    }
                } else if (i == parts.size() - 1) {
                    currentLine = parts[i];
                } else {
                    channel.send(parts[i]);
                }
            }
        }
        
        if (!currentLine.empty()) {
            channel.send(currentLine);
        }
        
        close(socket_fd);
        channel.close();
    });
    
    readerThread.detach();
    return channel;
}
```

Before the next networking snippet, consider:
1. How does the socket chunk reading mirror file chunk reading?  
2. What happens if `recv` returns 0?  
3. Why do we close the socket inside the thread instead of the caller?  
4. How might you surface errors (e.g., ECONNRESET) to the caller?  
5. How would TLS integration change this pattern?

```cpp
// udp_client.cpp
// Minimal UDP sender. Illustrates connectionless datagrams.
#include <iostream>
#include <string>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main() {
    int socket_fd = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (socket_fd < 0) { std::perror("socket"); return 1; }

    sockaddr_in server_address{};
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(8080);
    server_address.sin_addr.s_addr = ::inet_addr("127.0.0.1");

    std::string input;
    while (std::cout << ">> " && std::getline(std::cin, input) && input != "quit") {
        ssize_t sent = ::sendto(socket_fd, input.data(), input.size(), 0,
                                reinterpret_cast<sockaddr*>(&server_address), sizeof(server_address));
        if (sent < 0) { std::perror("sendto"); break; }
        std::cout << "Sent " << sent << " bytes\n";
    }
    ::close(socket_fd);
}
```

**Reader Tasks (Networking Warm‑Up)**
1. Write a matching UDP echo server that prints what it receives.  
2. Add a timestamp before each send (see `<chrono>`).  
3. Experiment: send a 10KB payload and observe if it fragments (use `tcpdump` / `wireshark`).  
4. Switch to IPv6 (use `sockaddr_in6`).  
5. Add basic retry logic on failed `sendto`.

***

## Chapter 4: HTTP Request Parsing
### Building a Robust HTTP Parser
Now that we understand data streaming, let's implement a **production-quality HTTP parser** that handles the complete request format.[30][31]

### 4.1 Request Class Design
HTTP requests consist of three parts: **request line**, **headers**, and **body**. Our parser must handle each component robustly:[32][33]

Before you read the interface, answer:
1. Which invariants should a valid request line satisfy?  
2. Should header keys preserve original case? Why/why not?  
3. How will you handle duplicate headers?  
4. Where will percent‑decoding of the path belong (if added)?  
5. How could you extend this design for HTTP/2 pseudo‑headers?

```cpp
// request.hpp
#pragma once
#include <string>
#include <map>
#include <stdexcept>
#include <sstream>
#include <algorithm>
#include <cctype>

class Request {
public:
    struct RequestLine { std::string method, path, version; };

    static Request fromStream(std::istream& stream);
    static RequestLine parseRequestLine(const std::string& line);

    // Accessors
    const std::string& getMethod()  const { return request_line_.method; }
    const std::string& getPath()    const { return request_line_.path; }
    const std::string& getVersion() const { return request_line_.version; }
    const std::string& getBody()    const { return body_; }
    const std::map<std::string,std::string>& getHeaders() const { return headers_; }
    bool hasHeader(const std::string& key) const { return headers_.find(key)!=headers_.end(); }
    std::string getHeader(const std::string& key) const { auto it=headers_.find(key); return it==headers_.end()?"":it->second; }

    // Mutators (used by streaming / parser components)
    void setRequestLine(RequestLine rl) { request_line_ = std::move(rl); }
    void setHeaders(const std::map<std::string,std::string>& h) { headers_ = h; }
    void setBody(std::string b) { body_ = std::move(b); }
    void addHeader(const std::string& key, const std::string& value) { headers_[key]=value; }

private:
    RequestLine request_line_{};
    std::map<std::string,std::string> headers_;
    std::string body_;
};
```

```cpp
// src/http/request.cpp
#include "request.hpp"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <cctype>

Request Request::fromStream(std::istream& stream) {
    Request request;
    std::string line;
    
    // Parse request line
    if (std::getline(stream, line)) {
        // Remove \r if present
        if (!line.empty() && line.back() == '\r') {
            line.pop_back();
        }
        request.request_line_ = parseRequestLine(line);
    }
    
    // Parse headers
    while (std::getline(stream, line)) {
        if (!line.empty() && line.back() == '\r') {
            line.pop_back();
        }
        
        if (line.empty()) break; // End of headers
        
        size_t colon_pos = line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = line.substr(0, colon_pos);
            std::string value = line.substr(colon_pos + 1);
            
            // Trim whitespace and convert key to lowercase
            key.erase(std::remove_if(key.begin(), key.end(), ::isspace), key.end());
            std::transform(key.begin(), key.end(), key.begin(), ::tolower);
            
            // Trim leading/trailing whitespace from value
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            
            request.headers_[key] = value;
        }
    }
    
    // Parse body if Content-Length present
    auto content_length_iter = request.headers_.find("content-length");
    if (content_length_iter != request.headers_.end()) {
        int length = std::stoi(content_length_iter->second);
        if (length > 0) {
            request.body_.resize(length);
            stream.read(&request.body_[0], length);
        }
    }
    
    return request;
}

Request::RequestLine Request::parseRequestLine(const std::string& line) {
    std::istringstream iss(line);
    RequestLine result;
    
    if (!(iss >> result.method >> result.path >> result.version)) {
        throw std::runtime_error("Invalid request line format");
    }
    
    // Validate method (uppercase letters only)
    for (char c : result.method) {
        if (!std::isupper(c)) {
            throw std::runtime_error("Invalid method format");
        }
    }
    
    // Validate HTTP version
    if (result.version != "HTTP/1.1") {
        throw std::runtime_error("Unsupported HTTP version");
    }
    
    return result;
}
```

**Implementation Features:**
- **Case-insensitive headers**: Following RFC 7230[33][32]
- **Robust parsing**: Handles various whitespace scenarios[30][34]
- **Error handling**: Clear exceptions for invalid input
- **RAII compliance**: Automatic resource management[27][26]

### 4.2 Streaming Parser for Real-Time Processing
For network connections, we need a **streaming parser** that handles partial data:[15][19]

Before you read the streaming parser code, think:
1. How do we know a request line is complete?  
2. How do we detect end of headers efficiently?  
3. What is the minimal buffer size needed for a valid small GET request?  
4. How would chunked transfer encoding alter state handling?  
5. What conditions transition to the Error state?

```cpp
// streaming_parser.hpp
#pragma once
#include "request.hpp"
#include <vector>

class StreamingParser {
public:
    enum class State { ParseRequestLine, ParseHeaders, ParseBody, Complete, Error };

    // Append & parse; returns bytes consumed from this call.
    std::size_t parse(const std::vector<char>& data);
    State getState() const { return state_; }
    const Request& getRequest() const { return request_; }

private:
    State state_ = State::ParseRequestLine;
    std::string buffer_;
    Request request_;
    std::size_t expected_body_length_ = 0;
};
```

```cpp
// streaming_parser.cpp
#include "streaming_parser.hpp"
#include <stdexcept>
#include <algorithm>
#include <cctype>

std::size_t StreamingParser::parse(const std::vector<char>& data) {
    if (state_ == State::Complete || state_ == State::Error) return 0;
    buffer_.append(data.begin(), data.end());
    std::size_t consumed = 0;
    while (true) {
        switch (state_) {
        case State::ParseRequestLine: {
            auto crlf = buffer_.find("\r\n");
            if (crlf == std::string::npos) return consumed; // need more
            try {
                auto line = buffer_.substr(0, crlf);
                request_.setRequestLine(Request::parseRequestLine(line));
                buffer_.erase(0, crlf + 2); consumed += crlf + 2; state_ = State::ParseHeaders;
            } catch (...) { state_ = State::Error; return consumed; }
            break; }
        case State::ParseHeaders: {
            auto crlf = buffer_.find("\r\n");
            if (crlf == std::string::npos) return consumed; // need more
            if (crlf == 0) { // end of headers
                buffer_.erase(0, 2); consumed += 2;
                if (request_.hasHeader("content-length")) {
                    expected_body_length_ = std::stoul(request_.getHeader("content-length"));
                    state_ = expected_body_length_ ? State::ParseBody : State::Complete;
                } else state_ = State::Complete;
            } else {
                auto line = buffer_.substr(0, crlf);
                auto colon = line.find(':');
                if (colon == std::string::npos) { state_ = State::Error; return consumed; }
                std::string key = line.substr(0, colon);
                std::string value = line.substr(colon + 1);
                // trim
                while(!value.empty() && (value.front()==' '||value.front()=='\t')) value.erase(value.begin());
                while(!value.empty() && (value.back()==' '||value.back()=='\t')) value.pop_back();
                // normalize key lower
                std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c){return std::tolower(c);});
                request_.addHeader(key, value);
                buffer_.erase(0, crlf + 2); consumed += crlf + 2;
            }
            break; }
        case State::ParseBody: {
            if (buffer_.size() < expected_body_length_) return consumed; // need more
            request_.setBody(buffer_.substr(0, expected_body_length_));
            buffer_.erase(0, expected_body_length_); consumed += expected_body_length_;
            state_ = State::Complete; break; }
        default: return consumed; }
    }
}
```

**Streaming Parser Benefits:**
- **Memory efficient**: Processes data as it arrives[38][15]
- **Partial data handling**: Works with incomplete network reads[19]
- **State preservation**: Maintains parsing context between calls[12][21]

**Reader Tasks (after 4.2)**
1. Add support for rejecting requests > N bytes before parsing fully.  
2. Detect header line length overflow (>8KB) and transition to Error.  
3. Add support for methods other than GET/POST (ensure uppercase validation).  
4. Instrument the parser: count bytes consumed per state and print metrics.  
5. Extend to parse query parameters into a `std::map` (store separately).

***

## Chapter 5: HTTP Headers Implementation
### Case-Insensitive Header Processing
HTTP headers are **case-insensitive** according to RFC 7230. Your implementation must handle `Content-Length`, `content-length`, and `CONTENT-LENGTH` identically.[32][33]

### 5.1 Headers Class Implementation
```cpp
// headers.hpp
#pragma once
#include <string>
#include <map>

class Headers {
public:
    void set(const std::string& key, const std::string& value);
    std::string get(const std::string& key) const;
    bool has(const std::string& key) const;
    std::size_t size() const { return headers_.size(); }
    std::size_t parse(const std::string& data, bool& done); // returns bytes consumed

    const std::map<std::string,std::string>& data() const { return headers_; }
private:
    std::map<std::string,std::string> headers_;
    std::string normalizeKey(const std::string& key) const;
    bool isValidHeaderChar(char c) const;
};
```

```cpp
// src/http/headers.cpp
#include "headers.hpp"
#include <algorithm>
#include <cctype>
#include <stdexcept>

void Headers::set(const std::string& key, const std::string& value) {
    std::string normalized_key = normalizeKey(key);
    
    // Check if header already exists (append with comma)
    auto it = headers_.find(normalized_key);
    if (it != headers_.end()) {
        it->second += ", " + value;
    } else {
        headers_[normalized_key] = value;
    }
}

std::string Headers::get(const std::string& key) const {
    std::string normalized_key = normalizeKey(key);
    auto it = headers_.find(normalized_key);
    return (it != headers_.end()) ? it->second : "";
}

bool Headers::has(const std::string& key) const {
    return headers_.find(normalizeKey(key)) != headers_.end();
}

size_t Headers::parse(const std::string& data, bool& done) {
    done = false;
    
    size_t crlf_pos = data.find("\r\n");
    if (crlf_pos == std::string::npos) {
        return 0; // Need more data
    }
    
    if (crlf_pos == 0) {
        done = true; // Empty line indicates end of headers
        return 2;
    }
    
    std::string line = data.substr(0, crlf_pos);
    size_t colon_pos = line.find(':');
    
    if (colon_pos == std::string::npos) {
        throw std::runtime_error("Invalid header format");
    }
    
    std::string key = line.substr(0, colon_pos);
    std::string value = line.substr(colon_pos + 1);
    
    // Validate key (no spaces allowed before colon)
    if (key.empty() || std::isspace(key.back())) {
        throw std::runtime_error("Invalid header key format");
    }
    
    // Validate key characters
    for (char c : key) {
        if (!isValidHeaderChar(c)) {
            throw std::runtime_error("Invalid character in header key");
        }
    }
    
    // Trim value whitespace
    value.erase(0, value.find_first_not_of(" \t"));
    value.erase(value.find_last_not_of(" \t") + 1);
    
    set(key, value);
    return crlf_pos + 2;
}

std::string Headers::normalizeKey(const std::string& key) const {
    std::string normalized = key;
    std::transform(normalized.begin(), normalized.end(), 
                   normalized.begin(), ::tolower);
    return normalized;
}

bool Headers::isValidHeaderChar(char c) const {
    // RFC 7230: field-name = token
    // token = 1*tchar
    // tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
    //         "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
    return std::isalnum(c) || 
           c == '!' || c == '#' || c == '$' || c == '%' || c == '&' ||
           c == '\'' || c == '*' || c == '+' || c == '-' || c == '.' ||
           c == '^' || c == '_' || c == '`' || c == '|' || c == '~';
}
```

**Header Processing Features:**
- **Case normalization**: All keys stored in lowercase[39][40]
- **Multiple values**: Comma-separated as per RFC[33][32]
- **Character validation**: Strict RFC compliance[34][30]
- **Whitespace handling**: Proper trimming of values[30][34]

**Reader Tasks (after 5.2)**
1. Add `erase(key)` method to remove a header.  
2. Support multi-value retrieval as `std::vector<std::string>` when values contain commas.  
3. Enforce a maximum header count (configurable).  
4. Add serialization function `toString()`.  
5. Write fuzz tests feeding random header lines (use a simple generator).

### 5.2 Testing Header Implementation
```cpp
// tests/test_headers.cpp
#include "catch.hpp"
#include "http/headers.hpp"

TEST_CASE("Case insensitive header access") {
    Headers headers;
    headers.set("Content-Type", "application/json");
    
    REQUIRE(headers.get("content-type") == "application/json");
    REQUIRE(headers.get("CONTENT-TYPE") == "application/json");
    REQUIRE(headers.get("Content-Type") == "application/json");
}

TEST_CASE("Multiple header values") {
    Headers headers;
    headers.set("Accept", "text/html");
    headers.set("Accept", "application/xml");
    
    REQUIRE(headers.get("accept") == "text/html, application/xml");
}

TEST_CASE("Header parsing with whitespace") {
    Headers headers;
    bool done;
    
    std::string data = "Content-Type:   application/json   \r\n";
    size_t consumed = headers.parse(data, done);
    
    REQUIRE(consumed == data.length());
    REQUIRE(!done);
    REQUIRE(headers.get("content-type") == "application/json");
}

TEST_CASE("Invalid header characters") {
    Headers headers;
    bool done;
    
    std::string data = "Content©Type: application/json\r\n";
    REQUIRE_THROWS(headers.parse(data, done));
}
```

***

## Chapter 6: HTTP Body and Content Handling
### Content-Length Based Body Parsing
HTTP message bodies are delimited by the `Content-Length` header. This tells us exactly how many bytes to read for the body.[34][30]

### 6.1 Complete Request Parser Integration
Let's integrate all our components into a complete HTTP request parser:

Before you inspect the integrated parser:
1. Where is buffering performed vs actual parsing?  
2. Why return 0 when more data is needed instead of throwing?  
3. How would you plug in incremental body decoding (e.g., streaming upload)?  
4. How can you guard against gigantic headers (malformed attack)?  
5. Could you unify this with the earlier `StreamingParser`?

```cpp
// request_parser.hpp
#pragma once
#include "request.hpp"
#include "headers.hpp"
#include <vector>

class RequestParser {
public:
    enum class State { ParseRequestLine, ParseHeaders, ParseBody, Complete, Error };
    std::size_t parse(const std::vector<char>& data);
    State getState() const { return state_; }
    const Request& getRequest() const { return request_; }
    std::string getErrorMessage() const { return error_message_; }
private:
    State state_ = State::ParseRequestLine;
    std::string buffer_;
    Request request_;
    Headers headers_;
    std::string error_message_;
    std::size_t expected_body_length_ = 0;
    std::size_t parseRequestLine();
    std::size_t parseHeaders();
    std::size_t parseBody();
};
```

```cpp
// src/http/request_parser.cpp
#include "request_parser.hpp"
#include <stdexcept>
#include <algorithm>

size_t RequestParser::parse(const std::vector<char>& data) {
    buffer_.append(data.begin(), data.end());
    size_t total_consumed = 0;
    
    while (state_ != State::Complete && state_ != State::Error) {
        size_t consumed = 0;
        
        try {
            switch (state_) {
            case State::ParseRequestLine:
                consumed = parseRequestLine();
                break;
            case State::ParseHeaders:
                consumed = parseHeaders();
                break;
            case State::ParseBody:
                consumed = parseBody();
                break;
            default:
                return total_consumed;
            }
        } catch (const std::exception& e) {
            error_message_ = e.what();
            state_ = State::Error;
            return total_consumed;
        }
        
        if (consumed == 0) {
            break; // Need more data
        }
        
        buffer_.erase(0, consumed);
        total_consumed += consumed;
    }
    
    return total_consumed;
}

size_t RequestParser::parseRequestLine() {
    size_t crlf_pos = buffer_.find("\r\n");
    if (crlf_pos == std::string::npos) {
        return 0; // Need more data
    }
    
    std::string line = buffer_.substr(0, crlf_pos);
    request_.setRequestLine(Request::parseRequestLine(line));
    
    state_ = State::ParseHeaders;
    return crlf_pos + 2;
}

size_t RequestParser::parseHeaders() {
    bool done = false;
    size_t consumed = headers_.parse(buffer_, done);
    
    if (consumed == 0) {
        return 0; // Need more data
    }
    
    if (done) {
        // Headers complete, check for body
        std::string content_length = headers_.get("content-length");
        if (!content_length.empty()) {
            expected_body_length_ = std::stoul(content_length);
            if (expected_body_length_ > 0) {
                state_ = State::ParseBody;
            } else {
                state_ = State::Complete;
            }
        } else {
            state_ = State::Complete;
        }
        
        request_.setHeaders(headers_);
    }
    
    return consumed;
}

size_t RequestParser::parseBody() {
    if (buffer_.size() < expected_body_length_) {
        return 0; // Need more data
    }
    request_.setBody(buffer_.substr(0, expected_body_length_));
    state_ = State::Complete;
    return expected_body_length_;
}
```

### 6.2 Testing Complete Request Parsing
```cpp
// tests/test_request_parser.cpp
#include "catch.hpp"
#include "http/request_parser.hpp"

TEST_CASE("Complete GET request parsing") {
    std::string raw_request = 
        "GET /api/users HTTP/1.1\r\n"
        "Host: example.com\r\n"
        "User-Agent: test-client/1.0\r\n"
        "\r\n";
    
    RequestParser parser;
    std::vector<char> data(raw_request.begin(), raw_request.end());
    
    size_t consumed = parser.parse(data);
    
    REQUIRE(consumed == raw_request.length());
    REQUIRE(parser.getState() == RequestParser::State::Complete);
    
    const auto& request = parser.getRequest();
    REQUIRE(request.getMethod() == "GET");
    REQUIRE(request.getPath() == "/api/users");
    REQUIRE(request.getHeader("host") == "example.com");
}

TEST_CASE("POST request with body") {
    std::string raw_request = 
        "POST /api/data HTTP/1.1\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: 25\r\n"
        "\r\n"
        "{\"message\":\"Hello\"}";
    
    RequestParser parser;
    std::vector<char> data(raw_request.begin(), raw_request.end());
    
    size_t consumed = parser.parse(data);
    
    REQUIRE(consumed == raw_request.length());
    REQUIRE(parser.getState() == RequestParser::State::Complete);
    REQUIRE(parser.getRequest().getBody() == "{\"message\":\"Hello\"}");
}

TEST_CASE("Chunked request parsing") {
    std::string part1 = "POST /api HTTP/1.1\r\n";
    std::string part2 = "Content-Length: 5\r\n\r\n";
    std::string part3 = "Hello";
    
    RequestParser parser;
    
    // Parse in chunks
    std::vector<char> data1(part1.begin(), part1.end());
    REQUIRE(parser.parse(data1) == part1.length());
    REQUIRE(parser.getState() == RequestParser::State::ParseHeaders);
    
    std::vector<char> data2(part2.begin(), part2.end());
    REQUIRE(parser.parse(data2) == part2.length());
    REQUIRE(parser.getState() == RequestParser::State::ParseBody);
    
    std::vector<char> data3(part3.begin(), part3.end());
    REQUIRE(parser.parse(data3) == part3.length());
    REQUIRE(parser.getState() == RequestParser::State::Complete);
    
    REQUIRE(parser.getRequest().getBody() == "Hello");
}
```

***

## Chapter 7: HTTP Server Implementation
### Building a Complete HTTP Server
Now we'll combine our parsing capabilities with TCP networking to create a real HTTP server.[7][22]

### 7.1 HTTP Server Architecture
```cpp
// server.hpp (minimal illustrative server – NOT production hardened)
#pragma once
#include "request_parser.hpp"
#include <functional>
#include <memory>
#include <atomic>

struct Response { // Lightweight response used by server example
    int status = 200;
    std::string reason = "OK";
    std::map<std::string,std::string> headers;
    std::string body;
    std::string toString() const {
        std::ostringstream oss;
        oss << "HTTP/1.1 " << status << ' ' << reason << "\r\n";
        for (auto& [k,v]: headers) oss << k << ": " << v << "\r\n";
        oss << "Content-Length: " << body.size() << "\r\n\r\n" << body;
        return oss.str();
    }
};

class HttpServer {
public:
    using Handler = std::function<Response(const Request&)>;
    explicit HttpServer(int port);
    ~HttpServer();
    void setHandler(Handler h) { handler_ = std::move(h); }
    void start();
    void stop();
private:
    int port_;
    int fd_ = -1;
    std::atomic_bool running_{false};
    Handler handler_;
    void acceptLoop();
    void serveClient(int client_fd);
};
```

```cpp
// server.cpp (minimal demo implementation)
#include "server.hpp"
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <thread>
#include <iostream>
#include <cstring>

HttpServer::HttpServer(int port) : port_(port) {
    fd_ = ::socket(AF_INET, SOCK_STREAM, 0);
    if (fd_ < 0) throw std::runtime_error("socket failed");
    int opt = 1; ::setsockopt(fd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    sockaddr_in addr{}; addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = htons(port_);
    if (::bind(fd_, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) throw std::runtime_error("bind failed");
    if (::listen(fd_, 16) < 0) throw std::runtime_error("listen failed");
}
HttpServer::~HttpServer(){ if (fd_>=0) ::close(fd_); }
void HttpServer::start(){ running_ = true; std::thread(&HttpServer::acceptLoop,this).detach(); }
void HttpServer::stop(){ running_ = false; }
void HttpServer::acceptLoop(){
    while (running_) {
        int cfd = ::accept(fd_, nullptr, nullptr);
        if (cfd < 0) { if (errno==EINTR) continue; break; }
        std::thread(&HttpServer::serveClient, this, cfd).detach();
    }
}
void HttpServer::serveClient(int client_fd){
    RequestParser parser;
    std::vector<char> buf(2048);
    while (parser.getState()!=RequestParser::State::Complete && parser.getState()!=RequestParser::State::Error){
        ssize_t n = ::recv(client_fd, buf.data(), buf.size(), 0);
        if (n<=0) break; // connection closed or error
        std::vector<char> chunk(buf.begin(), buf.begin()+n);
        parser.parse(chunk);
    }
    Response resp;
    if (parser.getState()==RequestParser::State::Complete && handler_){ resp = handler_(parser.getRequest()); }
    else { resp.status=400; resp.reason="Bad Request"; resp.body="Malformed"; }
    auto text = resp.toString();
    ::send(client_fd, text.data(), text.size(), 0);
    ::close(client_fd);
}
```

**Reader Tasks (Server Primer)**
1. Add logging for remote peer address (use `getpeername`).  
2. Implement graceful shutdown: close the listening socket then wait for active threads.  
3. Add a header `Date:` (see `<chrono>` + HTTP date formatting).  
4. Measure RPS with `wrk` or `ab` and vary buffer size.  
5. Replace per‑connection thread with a thread pool.

### 7.2 A Richer Response Type (Optional Enhancement)
```cpp
// response.hpp
#pragma once
#include <string>
#include <map>
#include <sstream>

class Response {
public:
    Response() = default;
    void setStatus(int code, std::string reason_="");
    void setHeader(const std::string& k, const std::string& v) { headers_[k]=v; }
    void setBody(std::string b) { body_=std::move(b); headers_["Content-Length"]=std::to_string(body_.size()); }
    const std::map<std::string,std::string>& headers() const { return headers_; }
    std::string toString() const;
private:
    int status_ = 200; std::string reason_ = "OK"; std::map<std::string,std::string> headers_; std::string body_;
    static std::string defaultReason(int code);
};
```
```cpp
// response.cpp
#include "response.hpp"

void Response::setStatus(int code, std::string reason){ status_=code; reason_=reason.empty()?defaultReason(code):std::move(reason); }
std::string Response::defaultReason(int code){ switch(code){case 200:return "OK";case 400:return "Bad Request";case 404:return "Not Found";case 500:return "Internal Server Error";default:return "Status";} }
std::string Response::toString() const {
    std::ostringstream oss;
    oss << "HTTP/1.1 "<<status_<<' '<<reason_<<"\r\n";
    for(auto&[k,v]:headers_) oss<<k<<": "<<v<<"\r\n";
    oss<<"\r\n"<<body_;
    return oss.str();
}
```

### 7.3 Chunked Transfer Writer
```cpp
// chunked_writer.hpp
#pragma once
#include <ostream>
#include <string>
#include <iomanip>
#include <sstream>

class ChunkedWriter {
public:
    explicit ChunkedWriter(std::ostream& out): out_(out) {}
    void writeChunk(const std::string& data);
    void finish();
private:
    std::ostream& out_; bool done_=false;
};
```
```cpp
// chunked_writer.cpp
#include "chunked_writer.hpp"

void ChunkedWriter::writeChunk(const std::string& data){
    if(done_) return; 
    std::ostringstream size_hex; size_hex<<std::hex<<data.size();
    out_<<size_hex.str()<<"\r\n"<<data<<"\r\n";
}
void ChunkedWriter::finish(){ if(done_) return; out_<<"0\r\n\r\n"; done_=true; }
```

### 7.4 Static File Server (Simplified)
```cpp
// file_server.hpp
#pragma once
#include <string>
#include <filesystem>
#include <fstream>
#include <map>
#include "response.hpp"

class FileServer {
public:
    static Response serveFile(const std::string& path);
private:
    static std::string mime(const std::string& ext);
};
```
```cpp
// file_server.cpp
#include "file_server.hpp"

Response FileServer::serveFile(const std::string& path){
    Response r; std::ifstream f(path, std::ios::binary|std::ios::ate); if(!f){ r.setStatus(404); r.setBody("Not Found"); return r; }
    auto size=f.tellg(); f.seekg(0); std::string data(size,'\0'); f.read(data.data(), size);
    r.setStatus(200); r.setHeader("Content-Type", mime(std::filesystem::path(path).extension().string())); r.setBody(std::move(data)); return r;
}
std::string FileServer::mime(const std::string& ext){ static const std::map<std::string,std::string> m{{".html","text/html"},{".txt","text/plain"},{".json","application/json"},{".png","image/png"}}; auto it=m.find(ext); return it==m.end()?"application/octet-stream":it->second; }
```

**Reader Tasks (Files & Responses)**
1. Add caching: keep an in‑memory map of small files with last modified time.
2. Serve directory listings (generate basic HTML).
3. Add ETag header (hash of content) & handle If-None-Match.
4. Extend ChunkedWriter to support trailers.
5. Write an integration test serving a known file.

### 8.1 Thread Pool for Performance
For production servers, use thread pools instead of a thread per connection.[45][46][3]
Before you open the code:
1. How do we safely stop worker threads?  
2. What happens to queued jobs after shutdown begins?  
3. How could you implement task prioritization?  
4. Where might contention arise?  
5. How do you avoid unbounded queue growth?
```cpp
// thread_pool.hpp
#pragma once
#include <vector>
#include <thread>
#include <queue>
#include <functional>
#include <mutex>
#include <condition_variable>
#include <atomic>

class ThreadPool {
public:
    explicit ThreadPool(std::size_t n);
    ~ThreadPool();
    void enqueue(std::function<void()> job);
    void shutdown();
private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> jobs_;
    std::mutex m_;
    std::condition_variable cv_;
    std::atomic_bool stop_{false};
    void worker();
};
```
```cpp
// thread_pool.cpp
#include "thread_pool.hpp"

ThreadPool::ThreadPool(std::size_t n){
    for(size_t i=0;i<n;++i) workers_.emplace_back(&ThreadPool::worker,this);
}
ThreadPool::~ThreadPool(){ shutdown(); }
void ThreadPool::enqueue(std::function<void()> job){
    {
        std::lock_guard lk(m_); if(stop_) return; jobs_.push(std::move(job));
    }
    cv_.notify_one();
}
void ThreadPool::shutdown(){
    {
        std::lock_guard lk(m_); if(stop_) return; stop_=true; }
    cv_.notify_all();
    for(auto& t: workers_) if(t.joinable()) t.join();
}
void ThreadPool::worker(){
    while(true){
        std::function<void()> job;
        {
            std::unique_lock lk(m_);
            cv_.wait(lk,[&]{return stop_||!jobs_.empty();});
            if(stop_ && jobs_.empty()) return;
            job = std::move(jobs_.front()); jobs_.pop();
        }
        job();
    }
}
```

**Reader Tasks (Thread Pool)**
1. Add a work queue size metric.  
2. Implement a bounded queue that blocks enqueue when full.  
3. Add a priority queue variant.  
4. Add RAII task wrapper that logs start/finish.  
5. Benchmark vs per‑thread approach.

***

## Chapter 9: Production-Ready Features
### 9.1 CMake Project Structure
A professional C++ project requires proper build system configuration:[14][13]

```cmake
# CMakeLists.txt (Root)
cmake_minimum_required(VERSION 3.16)
project(HttpFromTcp VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Compiler options
if(MSVC)
    add_compile_options(/W4)
else()
    add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Options
option(BUILD_TESTS "Build test programs" ON)
option(ENABLE_THREADING "Enable multithreading" ON)

# Find packages
if(ENABLE_THREADING)
    find_package(Threads REQUIRED)
endif()

# Add subdirectories
add_subdirectory(src)
if(BUILD_TESTS)
    enable_testing()
    add_subdirectory(tests)
endif()
```

### 9.2 Comprehensive Error Handling
Production code requires robust error handling:[27][26]

```cpp
// src/core/error_handler.hpp
#pragma once
#include <stdexcept>
#include <system_error>
#include <utility>

class HttpError : public std::runtime_error {
public:
    HttpError(int status_code, const std::string& message);
    int getStatusCode() const { return status_code_; }

private:
    int status_code_;
};

class NetworkError : public std::system_error {
public:
    NetworkError(const std::string& message);
    NetworkError(int error_code, const std::string& message);
};

// RAII socket wrapper
class SocketWrapper {
public:
    SocketWrapper(int fd = -1);
    ~SocketWrapper();
    
    SocketWrapper(const SocketWrapper&) = delete;
    SocketWrapper& operator=(const SocketWrapper&) = delete;
    
    SocketWrapper(SocketWrapper&& other) noexcept;
    SocketWrapper& operator=(SocketWrapper&& other) noexcept;
    
    int get() const { return fd_; }
    int release();
    void reset(int new_fd = -1);

private:
    int fd_;
};
```

### 9.3 Performance Optimization
Optimize for real-world usage:[15][16]

```cpp
// Performance optimizations
// Illustrative optimization wrapper (excerpt)
#include <sys/socket.h>
#include <netinet/tcp.h>
class OptimizedServer {
public:
    explicit OptimizedServer(int fd): fd_(fd) {}
    void optimizeForThroughput(){
        int on=1; ::setsockopt(fd_, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on));
        int buf=65536; ::setsockopt(fd_, SOL_SOCKET, SO_RCVBUF, &buf, sizeof(buf)); ::setsockopt(fd_, SOL_SOCKET, SO_SNDBUF, &buf, sizeof(buf));
    }
private: int fd_;
};
```

### 9.4 Security Considerations
Production servers need security measures:

```cpp
// Security features
class SecureServer {
private:
    size_t max_request_size_ = 1024 * 1024; // 1MB limit
    size_t max_header_count_ = 100;
    std::chrono::seconds request_timeout_{30};
    
public:
    bool validateRequest(const Request& request) {
        // Check request size
        if (request.getBody().size() > max_request_size_) {
            throw HttpError(413, "Request too large");
        }
        
        // Validate headers
        if (request.getHeaders().size() > max_header_count_) {
            throw HttpError(400, "Too many headers");
        }
        
        // Check for suspicious patterns
        if (request.getPath().find("..") != std::string::npos) {
            throw HttpError(400, "Invalid path");
        }
        
        return true;
    }
};
```

***

## Chapter 10: Modern HTTP and Beyond
### 10.1 HTTP/2 and HTTP/3 Overview
While we've implemented HTTP/1.1, understanding modern protocols is crucial:[47]

**HTTP/2 Features:**
- **Binary framing**: More efficient than text-based HTTP/1.1
- **Multiplexing**: Multiple requests over single connection
- **Header compression**: Reduces bandwidth usage
- **Server push**: Proactive resource delivery

**HTTP/3 Features:**
- **QUIC transport**: Built on UDP instead of TCP
- **Improved security**: Encryption by default
- **Better performance**: Reduced connection establishment time
- **Connection migration**: Survives network changes

### 10.2 Comparison with Modern Libraries
Our implementation compared to production libraries:[48][49]

| Feature | Our Implementation | cpp-httplib | Beast | nginx |
|---------|-------------------|-------------|-------|-------|
| Code Size | ~5K lines | ~8K lines | Large | Massive |
| Dependencies | None | None | Boost | Many |
| Performance | Good | Good | Excellent | Outstanding |
| HTTP/2 Support | No | No | Yes | Yes |
| Learning Value | Maximum | Medium | High | Low |

### 10.3 Production Deployment

For production deployment, consider:

```bash
# Build optimized version
cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTS=OFF
make -j$(nproc)

# Create systemd service
sudo cp httpfromtcp.service /etc/systemd/system/
sudo systemctl enable httpfromtcp
sudo systemctl start httpfromtcp

# Monitor with tools
htop                    # CPU/memory usage
netstat -tlnp          # Network connections  
strace -p         # System call tracing
valgrind --tool=memcheck # Memory leak detection
```

### 10.4 Next Steps
**Immediate Improvements:**
- Connection keep-alive support
- HTTP/1.1 pipelining
- Compression (gzip/deflate)
- SSL/TLS encryption

**Advanced Features:**
- WebSocket upgrade support
- HTTP/2 server push
- Load balancing capabilities
- Metrics and monitoring

**Architecture Enhancements:**
- Event-driven I/O with epoll/kqueue
- Zero-copy networking techniques
- Custom memory allocators
- Microservice integration

**Reader Tasks (Production Features)**
1. Add a `Keep-Alive` implementation with timeout & connection reuse counter.  
2. Implement gzip compression for `text/*` responses (use zlib if allowed; otherwise outline API).  
3. Add rate limiting: simple token bucket per client IP.  
4. Integrate a metrics endpoint `/metrics` exposing request count & latency histogram.  
5. Add a configuration layer (parse a TOML/JSON file) for port, thread count, and limits.

## Course Conclusion
Congratulations! You've built a complete HTTP server from scratch in C++, gaining deep understanding of:

✅ **Network Programming**: TCP/UDP sockets, connection management[5][4]
✅ **Protocol Implementation**: HTTP/1.1 parsing and generation[34][30]
✅ **System Design**: State machines, threading, resource management[21][26]
✅ **Testing**: TDD with Catch2, comprehensive test coverage[36][35]
✅ **Production**: CMake, security, performance optimization[13][14]

**You now understand** how web servers work at the lowest level, from TCP packets to HTTP responses. This knowledge will make you a better developer whether you're building web applications, APIs, or distributed systems.

**The journey continues** - take these fundamentals and explore modern web technologies, knowing exactly what happens under the hood when a browser requests a web page.

*Remember: Every time you make an HTTP request, this exact process is happening somewhere in the world. You've built it yourself.*

[1] https://cpp-netlib.org/0.9.0/hello_world_server.html
[2] https://github.com/Dungyichao/http_server
[3] https://github.com/MaxwellKnight/http-server-cpp
[4] https://www.tutorialspoint.com/cplusplus/cpp_socket_programming.htm
[5] https://www.geeksforgeeks.org/cpp/socket-programming-in-cpp/
[6] https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739
[7] https://github.com/SweetIceLolly/multithreaded-http-server
[8] https://app.codecrafters.io/courses/http-server/overview
[9] https://jyotinder.substack.com/p/implementing-go-channels-in-cpp
[10] https://dev.to/hardenedsteel/go-like-channels-in-c-3i7h
[11] https://trungams.github.io/2020-08-23-a-simple-http-server-from-scratch/
[12] https://bhch.github.io/posts/2017/11/writing-an-http-server-from-scratch/
[13] https://www.incredibuild.com/blog/how-to-set-up-new-projects-on-cmake-for-success
[14] https://palikar.github.io/posts/cmake_structure/
[15] https://www.geeksforgeeks.org/cpp/what-is-the-efficient-way-of-reading-a-huge-text-file/
[16] https://www.fromdev.com/2025/05/how-to-read-file-stream-data-to-string-in-c-2025-guide.html
[17] https://www.goanywhere.com/blog/http-vs-tcp-whats-the-difference
[18] https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview
[19] https://www.roxlu.com/2015/054/reading-chunks-from-a-buffer
[20] https://www.scaler.com/topics/cpp-read-file-line-by-line/
[21] https://softwarepatterns.com/cpp/state-software-pattern-cpp-example
[22] https://www.systutorials.com/how-to-process-a-file-line-by-line-in-c/
[23] https://stackoverflow.com/questions/11621232/c-parsing-http-chunked-transfer-encoding-response
[24] http://cppatomic.blogspot.com/2018/05/modern-effective-c-alternative-to.html
[25] https://www.reddit.com/r/cpp/comments/myliey/copper_powerful_and_convenient_communication/
[26] https://federicosarrocco.com/blog/cpp-memory-management-blog-post
[27] https://www.codeproject.com/Articles/5257335/Memory-Management-and-RAII
[28] https://www.swiftorial.com/swiftlessons/http-protocols/http-fundamentals/tcp-ip-and-http
[29] https://dev.to/dev_ojay/a-beginners-guide-to-networking-protocols-tcp-udp-http-and-http3-3pp6
[30] https://httpwg.org/specs/rfc7230.html
[31] https://datatracker.ietf.org/doc/html/rfc7231
[32] https://stackoverflow.com/questions/5258977/are-http-headers-case-sensitive
[33] https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html
[34] https://www.rfc-editor.org/rfc/rfc9112.html
[35] https://snorristurluson.github.io/Catch2/
[36] https://simplifycpp.org/?id=a0212
[37] https://stackoverflow.com/questions/242926/comparison-of-c-unit-test-frameworks
[38] https://www.youtube.com/watch?v=vwbWD3FO89c
[39] https://www.netdata.cloud/academy/how-to-find-memory-leak-in-c/
[40] https://educatedguesswork.org/posts/memory-management-2/
[41] https://1973.beastdocs.prtest.cppalliance.org/libs/beast/doc/html/beast/using_http/chunked_encoding.html
[42] https://stackoverflow.com/questions/10286132/binary-through-http
[43] https://cboard.cprogramming.com/c-programming/154167-sending-binary-data-via-http-response.html
[44] https://dev.to/sebastienfilion/building-a-http-server-from-scratch-implementing-file-download-and-upload-438d
[45] https://www.youtube.com/watch?v=FMNnusHqjpw
[46] https://stackoverflow.com/questions/8304182/how-should-i-implement-a-thread-pool-in-c
[47] https://www.youtube.com/watch?v=FknTw9bJsXM
[48] https://hub.paper-checker.com/blog/comprehensive-guide-to-http-libraries-in-c/
[49] https://github.com/yhirose/cpp-httplib
[50] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/8846678/8880ad2f-cc00-4502-bdaf-a1d3abd1186f/paste.txt
[51] https://www.linkedin.com/posts/animeshchaudhri_httpserver-cplusplus-multithreading-activity-7189056162674180096-GAX5
[52] https://www.keypuncher.net/blog/network-sockets-in-c
[53] https://stackoverflow.com/questions/8299323/implementation-of-http-in-c
[54] https://www.reddit.com/r/cpp_questions/comments/1kdpy26/making_an_http_server_from_scrach/
[55] https://www.reddit.com/r/C_Programming/comments/lmarcj/recommended_socket_programming_books/
[56] https://www.linuxhowtos.org/C_C++/socket.htm
[57] https://www.youtube.com/watch?v=YwHErWJIh6Y
[58] https://denizhalil.com/2025/01/11/c-plus-plus-network-programming-guide/
[59] https://userver.tech/da/d16/md_en_2userver_2tutorial_2hello__service.html
[60] https://beej.us/guide/bgnet/
[61] https://www.reddit.com/r/cpp_questions/comments/1d0x2fj/learning_to_build_an_http_webserver_in_c/
[62] https://dev.to/saumyaaggarwal/demystifying-socket-programming-build-your-own-http-server-in-c-oa9
[63] https://mangohost.net/blog/string-uppercase-and-lowercase-in-c/
[64] https://mendsley.github.io/2012/12/19/tinyhttp.html
[65] https://www.unwoundstack.com/blog/dependent-types-and-http-headers.html
[66] https://www.youtube.com/watch?v=s9fji4I_iOU
[67] https://github.com/netty/netty/issues/11104
[68] https://github.com/h2o/picohttpparser
[69] https://blog.cloudkernels.net/posts/testing_post/
[70] https://github.com/nodejs/node-v0.x-archive/issues/1954
[71] https://gist.github.com/CMCDragonkai/6bfade6431e9ffb7fe88
[72] https://www.reddit.com/r/cpp/comments/18xkod7/favorite_testing_framework/
[73] https://beta.boost.org/doc/libs/1_68_0/libs/beast/doc/html/beast/using_http/buffer_oriented_parsing.html
[74] https://news.ycombinator.com/item?id=42235981
[75] https://learn.microsoft.com/en-us/answers/questions/1464229/what-is-the-best-way-to-implement-multi-threading
[76] https://www.dominikgrabiec.com/posts/2022/11/11/setting_up_basic_project_cmake_visual_studio.html
[77] https://www.reddit.com/r/C_Programming/comments/4otvcx/help_with_operating_systems_assignment/
[78] https://stackoverflow.com/questions/63916507/c-cmake-project-structure-for-lib-and-executable
[79] https://www.reddit.com/r/cpp/comments/v9wgqu/project_structure_and_best_bractices_for_complex/
[80] https://codesignal.com/learn/courses/efficient-api-interactions-with-cpp/lessons/uploading-files-to-an-api-using-cpp
[81] https://discourse.cmake.org/t/best-practice-directory-structure-with-libraries/7345
[82] https://groups.google.com/g/microsoft.public.vc.language/c/dSkoMuHRJug/m/_R_f_7hZWC4J
[83] https://gregorykelleher.com/interview_practice_questions
[84] https://refactoring.guru/design-patterns/state/cpp/example
[85] https://www.codeproject.com/Articles/1087619/State-Machine-Design-in-Cplusplus-2
[86] https://dev.to/10xlearner/memory-management-and-raii-4f20
[87] https://www.geeksforgeeks.org/system-design/state-method-design-pattern-c-design-patterns/
[88] https://datatracker.ietf.org/doc/html/rfc2616
[89] https://honeytreelabs.com/posts/real-time-state-machine-in-cpp/
[90] https://www.w3.org/Protocols/rfc2616/rfc2616.html
[91] https://www.reddit.com/r/embedded/comments/10o3i2x/what_is_your_way_to_go_for_state_machines_in_c/
[92] https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
[93] https://stackoverflow.com/questions/10705754/c-memory-management-techniques-practices
[94] https://www.embeddedrelated.com/showarticle/1628.php
[95] https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Resources_and_specifications